#### 06 | 链表（上）：如何实现LRU缓存淘汰算法?

链表也是一种线性表，但在内存上是非连续存储的。

##### 非连续存储

链表中的元素，为了保持元素间的线性关系，需要额外的字段来维持前后元素的一一对应。

优点：

支持高效动态扩容，申请一个元素绑定下关系就可以了；

相比于数组需要连续的内存空间，链表可以利用零散的内存空间完成数据的存储，比如当内存中没有足够大的连续的空间的时候；

缺点：

不支持随机访问，想要访问一个元素只能遍历链表

##### 单链表 

最简单，最常用的链表。通过一个后继指针 next 记录下一个节点的位置。

头节点：第一个节点，有些时候头节点不存储数据，或者存储链表的长度等等

尾节点：最后一个节点，next 指向空地址 NULL

##### 不支持随机访问

因为内存不连续，不能进行随机访问，想要访问第 k 个节点，只能从链表头遍历，数到第 k 个节点，时间复杂度 O(n)。

##### 插入删除

节点的插入删除，不需要进行数据的搬移，只要改变下相邻节点的指向关系就可以了，时间复杂度 O(1)。

但实际并不这么简单，因为链表不支持随机访问。

比如删除数据，可以分为两种情况：

- 删除节点中值等于某个特定值的节点
  需要遍历链表，找到值等于某个特定值得节点，查找时间复杂度 O(n)，删除时间复杂度 O(1)
- 删除给定指针指向的节点
  单向链表需要遍历链表，查找时间复杂度 O(n)，删除时间复杂度 O(1)
  双向链表因为有前驱和后继两个指针，可以轻松搞定，时间复杂度 O(1)

插入也是同理。

##### 循环链表

最后一个节点的 next 指向头结点。如果要处理的数据具有环形结构特点，比较适合使用，比如[约瑟夫问题](https://zh.wikipedia.org/wiki/%E7%BA%A6%E7%91%9F%E5%A4%AB%E6%96%AF%E9%97%AE%E9%A2%98)。

##### 双向链表

节点间有前驱指针 prev 和 后继指针 next 两个方向。虽然更浪费空间，但是更灵活，实际开发中更常用。因为双向链表可以方便的找到一个节点的前驱节点，时间复杂度O(1)。

##### 双向循环链表

双向链表和循环链表的结合体。

##### LRU缓存淘汰算法

LRU(Least Recently Used) 最近最少使用，在有限的缓存中保留那些最近使用最多的数据，当缓存满时，删除那些最少使用的数据以便存储新数据。

因为需要频繁的添加、更新、删除数据，所以很适合使用链表来实现：

维护一个单链表，链表头部是最近访问的数据，链表尾部是最早访问的数据；

当有一个新数据被访问时，从头部遍历链表，如果存在链表中，从该位置删除，插入到链表头部；

如果不在链表中，如果链表未满，直接插入到链表头部；

如果不在链表中，如果链表满了，删除链表尾部节点，再插入到链表头部；

这就是一个简单的 LRU 算法，缓存访问的时间复杂度 O(n)，效率并不高。

##### 总结

链表，非连续存储的线性表，支持动态扩容，适合频繁插入、删除的场景，不支持随机访问；而数组适合随机访问

，插入、删除不频繁的场景。