#### 04 | 复杂度分析（下）：浅析最好、最坏、平均、均摊时间复杂度

##### 最好情况时间复杂度

在最理想的情况下，代码执行的时间复杂度

##### 最坏情况时间复杂度

在最糟糕的情况下，代码执行的时间复杂度

一个例子：在一个无序数组中，查找变量 x 出现的位置。

```java
// n 表示数组 array 的长度
int find(int[] array, int n, int x) {
  int i = 0;
  int pos = -1;
  for (; i < n; ++i) {
    if (array[i] == x) {
       pos = i;
       break;
    }
  }
  return pos;
}
```

在遍历数组过程中，如果找到变量，会提前退出循环，也就是说存在不需要遍历完数组的情况。

最糟糕的情况就是，变量 x 不在数组中，那么就需要遍历完数组，复杂度为 O(n)

最理想的情况就是，变量 x 在数组第一个元素，复杂度为 O(1)

上述代码的最好情况时间复杂度 O(1)，最坏情况时间复杂度 O(n)



但是最好/最坏情况时间复杂度是两个极端情况，发生的概率并不大，所以需要一个平均情况下的时间复杂度。

##### 平均情况时间复杂度

用概率统计的方法，统计加权平均时间复杂度

上面那个例子：

变量 x 可能在数组中，也可能不在数组中，假设两种概率都为 1/2，同时假设变量在数组中时出现在每个位置的概率一样为 1/n，那么平均时间复杂度就是 O(n)

![](平均时间复杂度.jpg)

##### 均摊时间复杂度

均摊分析

一个例子：往数组中插入数据，如果数组有空闲，直接插入，如果数组满了，对数据元素求和放在首位并清空数组，再插入。

```java
 // array 表示一个长度为 n 的数组
 // 代码中的 array.length 就等于 n
 int[] array = new int[n];
 int count = 0;
 
 void insert(int val) {
    if (count == array.length) {
       int sum = 0;
       for (int i = 0; i < array.length; ++i) {
          sum = sum + array[i];
       }
       array[0] = sum;
       count = 1;
    }

    array[count] = val;
    ++count;
 }
```

最好情况下，数组有空闲，直接插入，复杂度 O(1)

最坏情况下，数组满了，先求和清空，再插入，复杂度 O(n)

数组长度为 n，有 n 中情况下，插入的复杂度为 O(1)，还有一种情况，数组满，插入的复杂度为 O(n)，平均情况就是 O(1)：

![](均摊时间复杂度.jpg)

均摊分析的思路简单些：

每一次 O(n) 的插入操作后面，都会跟着 n-1 次 O(1) 的插入操作，把那一个 O(n) 的操作均摊到接下来的 n-1 次操作上，那么每次的复杂度就是 O(1)

> 均摊时间复杂度是一种比较特殊的平均时间复杂度